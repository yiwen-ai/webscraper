const {
  createHash,
} = await import('node:crypto')
import { Buffer } from 'node:buffer'

import { types, Client } from 'cassandra-driver'
import Long from 'long'
import { Request } from '@crawlee/core'
import { encode } from 'cbor-x'

const MAX_CELL_SIZE = 1024 * 1024 - 1 // 1MB

// @ts-ignore
if (BigInt.prototype.toJSON == null) {
  // @ts-ignore
  BigInt.prototype.toJSON = function () {
    return this.toString()
  }
}

// CREATE TABLE IF NOT EXISTS ywws.cnt
// (
//     key TEXT,
//     cnt COUNTER,
//     PRIMARY KEY (key)
// )

interface CounterRow {
  key: string
  cnt: types.Long
}

export interface CounterJSON {
  key: string
  cnt: BigInt
}

export class Counter {
  row: CounterRow

  constructor(key: string) {
    this.row = Object.create(null)
    this.row.key = key
    this.row.cnt = types.Long.fromInt(0)
  }

  toJSON(): CounterJSON {
    return {
      key: this.row.key,
      cnt: BigInt(this.row.cnt.toString()),
    }
  }

  async fill(cli: Client) {
    const query = 'SELECT cnt FROM cnt WHERE key=? LIMIT 1'
    const params = [this.row.key]

    const result = await cli.execute(query, params, {prepare: true})
    const row = result.first()
    if (row == null) {
      throw new Error(`Counter ${this.row.key} not found`)
    }

    this.row.cnt = row.get('cnt')
  }

  async incrOne(cli: Client) {
    const query = 'UPDATE cnt SET cnt=cnt+1 WHERE key=?'
    const params = [this.row.key]

    await cli.execute(query, params, {prepare: true})
  }

  static get tableName() {
    return 'cnt'
  }

  static get columns() {
    return ['key', 'cnt']
  }
}

// CREATE TABLE IF NOT EXISTS ywws.doc:
// oid   BLOB,       # SHA3_256(unique Url)
// at    BIGINT,     # create at, a timestamp (date and time) with second precision.
// url   TEXT,       # unique Url, generated by crawlee
// src   TEXT,       # source Url
// title TEXT,       # document title
// meta  MAP<text, text>,  # document meta info. e.g. author, keywords, description, etc.
// cbor  BLOB,       # document content in CBOR format
// html  TEXT,       # document content in html format
// page  TEXT,       # full page content in html format

export interface Meta {
  [index: string]: string
}

interface DocumentRow {
  oid: Buffer
  at: types.Long
  url: string
  src: string
  title: string
  meta: Meta
  cbor: Buffer | null
  html: string
  page: string
}

export interface DocumentJSON {
  oid: Buffer
  at: BigInt
  url: string
  src: string
  title: string
  meta: Meta
  cbor: Buffer | null
  html: string
  page: string
}

export class Document {
  id: Buffer
  row: DocumentRow

  static fromUrl(url: string) {
    const doc = new Document()
    const req = new Request({url: url})

    sha1(req.uniqueKey).copy(doc.id)
    doc.row.at = types.Long.fromInt(Math.floor(Date.now()/1000))
    doc.row.url = req.uniqueKey
    doc.row.src = url
    doc._fillAt()

    return doc
  }

  static fromId(id: Buffer) {
    const doc = new Document()
    id.copy(doc.id)
    const bytes = new Array<number>(8)
    for (let i = 0; i < 8; i++) {
      bytes[i] = doc.id[20+i]
    }
    // types.Long is a old version of Long
    doc.row.at = types.Long.fromValue(Long.fromBytesBE(bytes))
    return doc
  }

  constructor() {
    this.id = Buffer.alloc(28)
    this.row = Object.create(null)

    this.row.oid = this.id.slice(0, 20)
    this.row.at = types.Long.fromInt(0)
    this.row.url = ''
    this.row.src = ''
    this.row.title = ''
    this.row.meta = {}
    this.row.cbor = null
    this.row.html = ''
    this.row.page = ''
  }

  get isFresh(): boolean {
    return this.row.title != '' && this.row.at.gt(Math.floor(Date.now()/1000) -3600)
  }

  toJSON(): DocumentJSON {
    return {
      oid: this.row.oid,
      at: BigInt(this.row.at.toString()),
      url: this.row.url,
      src: this.row.src,
      title: this.row.title,
      meta: this.row.meta || {},
      cbor: this.row.cbor,
      html: this.row.html,
      page: this.row.page,
    }
  }

  setTitle(str: string) {
    if (str.indexOf('\n') >= 0) {
      str = str.replace(/\n/g, ' ')
    }
    this.row.title = str.trim()
  }

  setMeta(meta: Meta) {
    if (meta != null && typeof meta == 'object') {
      this.row.meta = meta
    }
  }

  setCBOR(json: Object) {
    this.row.cbor = encode(json)
  }

  setHTML(str: string) {
    this.row.html = str.trim()
  }

  setPage(str: string) {
    this.row.page = str.trim()
  }

  _fillAt() {
    const bytes = Long.fromValue(this.row.at).toBytesBE()
    for (let i = 0; i < 8; i++) {
      this.id[20+i] = bytes[i]
    }
  }

  async fill(cli: Client, selectColumns: string[] = ['url', 'src', 'title', 'meta', 'cbor', 'html', 'page']) {
    const query = `SELECT ${selectColumns.join(',')} FROM doc WHERE oid=? AND at=? LIMIT 1`
    const params = [this.row.oid, this.row.at] // find the document in a hour.

    const result = await cli.execute(query, params, {prepare: true})
    const row = result.first()
    if (row == null) {
      throw new Error(`Document ${this.row.src || this.id.toString('base64url')} at ${this.row.at.toString()} not found`)
    }

    // @ts-ignore
    row.forEach((value, name) => this.row[name] = value)
  }

  async insert(cli: Client) {
    if (this.row.cbor == null) {
      throw new Error('Document cbor is null')
    }

    if (Buffer.byteLength(this.row.page, 'utf8') > MAX_CELL_SIZE || this.row.cbor.length > MAX_CELL_SIZE) {
      throw new Error(`Document ${this.row.src} is too large`)
    }

    const columns = Document.columns
    const query = `INSERT INTO doc (${columns.join(',')}) VALUES (${columns.map((c) => '?').join(',')}) IF NOT EXISTS`
    // @ts-ignore
    const params = columns.map((c) => this.row[c])

    await cli.execute(query, params, {prepare: true})
  }

  static async findLatest(cli: Client, url: string) {
    const doc = Document.fromUrl(url)

    const query = 'SELECT at,title FROM doc WHERE oid=? LIMIT 1'
    const params = [doc.row.oid]

    const result = await cli.execute(query, params, {prepare: true})
    const row = result.first()
    if (row != null) {
      doc.row.at = row.get('at')
      doc.row.title = row.get('title')
      doc._fillAt()
    }
    return doc
  }

  static get tableName() {
    return 'art'
  }

  static get columns() {
    return ['oid', 'at', 'url', 'src', 'title', 'meta', 'cbor', 'html', 'page']
  }
}

function sha1(str: string) {
  const hash = createHash('sha1')
  hash.update(str, 'utf8')
  return hash.digest()
}