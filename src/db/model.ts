import { Buffer } from 'node:buffer'

import { types, type Client } from 'cassandra-driver'
import Long from 'long'
import { Request } from '@crawlee/core'
import { encode } from 'cbor-x'
const {
  createHash
} = await import('node:crypto')

const MAX_CELL_SIZE = 1024 * 1024 - 1 // 1MB

// @ts-expect-error: should ignore
if (BigInt.prototype.toJSON == null) {
  /* eslint no-extend-native: ["error", { "exceptions": ["BigInt"] }] */
  // @ts-expect-error: should ignore
  BigInt.prototype.toJSON = function () {
    return this.toString()
  }
}

// CREATE TABLE IF NOT EXISTS ywws.cnt
// (
//     key TEXT,
//     cnt COUNTER,
//     PRIMARY KEY (key)
// )

interface CounterRow {
  key: string
  cnt: types.Long
}

export interface CounterJSON {
  key: string
  cnt: bigint
}

export class Counter {
  row: CounterRow

  constructor (key: string) {
    this.row = Object.create(null)
    this.row.key = key
    this.row.cnt = types.Long.fromInt(0)
  }

  toJSON (): CounterJSON {
    return {
      key: this.row.key,
      cnt: BigInt(this.row.cnt.toString())
    }
  }

  async fill (cli: Client): Promise<void> {
    const query = 'SELECT cnt FROM cnt WHERE key=? LIMIT 1'
    const params = [this.row.key]

    const result = await cli.execute(query, params, { prepare: true })
    const row = result.first()
    if (row == null) {
      throw new Error(`Counter ${this.row.key} not found`)
    }

    this.row.cnt = row.get('cnt')
  }

  async incrOne (cli: Client): Promise<void> {
    const query = 'UPDATE cnt SET cnt=cnt+1 WHERE key=?'
    const params = [this.row.key]

    await cli.execute(query, params, { prepare: true })
  }

  static readonly tableName = 'cnt'

  static get columns (): string[] {
    return ['key', 'cnt']
  }
}

// CREATE TABLE IF NOT EXISTS ywws.doc:
// oid   BLOB,       # SHA3_256(unique Url)
// at    BIGINT,     # create at, a timestamp (date and time) with second precision.
// url   TEXT,       # unique Url, generated by crawlee
// src   TEXT,       # source Url
// title TEXT,       # document title
// meta  MAP<text, text>,  # document meta info. e.g. author, keywords, description, etc.
// cbor  BLOB,       # document content in CBOR format
// html  TEXT,       # document content in html format
// page  TEXT,       # full page content in html format

export type Meta = Record<string, string>

interface DocumentRow {
  oid: Buffer
  at: types.Long
  url: string
  src: string
  title: string
  meta: Meta
  cbor: Buffer | null
  html: string
  page: string
}

export interface DocumentJSON {
  oid: Buffer
  at: bigint
  url: string
  src: string
  title: string
  meta: Meta
  cbor: Buffer | null
  html: string
  page: string
}

export class Document {
  id: Buffer
  row: DocumentRow

  static fromUrl (url: string): Document {
    const doc = new Document()
    const req = new Request({ url })

    sha1(req.uniqueKey).copy(doc.id)
    doc.row.at = types.Long.fromInt(Math.floor(Date.now() / 1000))
    doc.row.url = req.uniqueKey
    doc.row.src = url
    doc._fillAt()

    return doc
  }

  static fromId (id: Buffer): Document {
    const doc = new Document()
    id.copy(doc.id)
    const bytes = new Array<number>(8)
    for (let i = 0; i < 8; i++) {
      bytes[i] = doc.id[20 + i]
    }
    // types.Long is a old version of Long
    doc.row.at = types.Long.fromValue(Long.fromBytesBE(bytes))
    return doc
  }

  constructor () {
    this.id = Buffer.alloc(28)
    this.row = Object.create(null)

    this.row.oid = this.id.slice(0, 20)
    this.row.at = types.Long.fromInt(0)
    this.row.url = ''
    this.row.src = ''
    this.row.title = ''
    this.row.meta = {}
    this.row.cbor = null
    this.row.html = ''
    this.row.page = ''
  }

  get isFresh (): boolean {
    return this.row.title !== '' && this.row.at.gt(Math.floor(Date.now() / 1000) - 3600)
  }

  toJSON (): DocumentJSON {
    return {
      oid: this.row.oid,
      at: BigInt(this.row.at.toString()),
      url: this.row.url,
      src: this.row.src,
      title: this.row.title,
      meta: this.row.meta,
      cbor: this.row.cbor,
      html: this.row.html,
      page: this.row.page
    }
  }

  setTitle (str: string): void {
    if (str.includes('\n')) {
      str = str.replace(/\n/g, ' ')
    }
    this.row.title = str.trim()
  }

  setMeta (meta: Meta): void {
    if (meta != null && typeof meta === 'object') {
      this.row.meta = meta
    }
  }

  setCBOR (json: any): void {
    this.row.cbor = encode(json)
  }

  setHTML (str: string): void {
    this.row.html = str.trim()
  }

  setPage (str: string): void {
    this.row.page = str.trim()
  }

  _fillAt (): void {
    const bytes = Long.fromValue(this.row.at).toBytesBE()
    for (let i = 0; i < 8; i++) {
      this.id[20 + i] = bytes[i]
    }
  }

  async fill (cli: Client, selectColumns: string[] = ['url', 'src', 'title', 'meta', 'cbor', 'html', 'page']): Promise<void> {
    const query = `SELECT ${selectColumns.join(',')} FROM doc WHERE oid=? AND at=? LIMIT 1`
    const params = [this.row.oid, this.row.at] // find the document in a hour.

    const result = await cli.execute(query, params, { prepare: true })
    const row = result.first()
    if (row == null) {
      const name = this.row.src !== '' ? this.row.src : this.id.toString('base64url')
      throw new Error(`Document ${name} at ${this.row.at.toString()} not found`)
    }

    // @ts-expect-error: should ignore
    row.forEach((value, name) => {
      // @ts-expect-error: should ignore
      this.row[name] = value
    })
  }

  async insert (cli: Client): Promise<void> {
    if (this.row.cbor == null) {
      throw new Error('Document cbor is null')
    }

    if (Buffer.byteLength(this.row.page, 'utf8') > MAX_CELL_SIZE || this.row.cbor.length > MAX_CELL_SIZE) {
      throw new Error(`Document ${this.row.src} is too large`)
    }

    const columns = Document.columns
    const query = `INSERT INTO doc (${columns.join(',')}) VALUES (${columns.map((c) => '?').join(',')}) IF NOT EXISTS`
    // @ts-expect-error: should ignore
    const params = columns.map((c) => this.row[c])

    await cli.execute(query, params, { prepare: true })
  }

  static async findLatest (cli: Client, url: string): Promise<Document> {
    const doc = Document.fromUrl(url)

    const query = 'SELECT at,title FROM doc WHERE oid=? LIMIT 1'
    const params = [doc.row.oid]

    const result = await cli.execute(query, params, { prepare: true })
    const row = result.first()
    if (row != null) {
      doc.row.at = row.get('at')
      doc.row.title = row.get('title')
      doc._fillAt()
    }
    return doc
  }

  static readonly tableName = 'art'

  static get columns (): string[] {
    return ['oid', 'at', 'url', 'src', 'title', 'meta', 'cbor', 'html', 'page']
  }
}

function sha1 (str: string): Buffer {
  const hash = createHash('sha1')
  hash.update(str, 'utf8')
  return hash.digest()
}
